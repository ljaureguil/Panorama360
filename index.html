<!DOCTYPE html>
<html lang="en">

<head>
    <title>CubemapToEquirectangular - Managed</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            color: white;
            margin: 0px;
            overflow: hidden;
        }
        #capture {
            position: absolute;
            left: 20px;
            top: 20px;
            padding: 10px;
            border: 1px solid white;
            z-index: 100;
            cursor: pointer;
            background-color: rgba(0, 0, 0, .4);
        }
        .csels {
            background: rgba(100, 100, 1000, .35);
            color: white;
        }
        button {
            margin: 5px;
            background: rgba(100, 100, 1000, .35);
            color: white;
        }
        select {
            margin: 5px;
        }
        #dparam {
            width: 100%;
            height: 100%;
            border-style: solid;
            display: none;
        }
        #params {
            width: 50%;
            height: 200px;
            background: rgba(255, 255, 255, .75);
        }
        #file {
            width: 80px;
            // background: url(https://icons-for-free.com/iconfiles/png/512/folder+open+icon-1320161390409087972.png);
            // background-size: 100% 100%;
            ;
        }
        #ct {
            display: none;
        }
        #smeshes {
            display: none
        }
    </style>
</head>

<body>


<div id="todo">


    <div id="capture">
        <button id="bm" onclick="if(ct.style.display!='none')ct.style.display='none';else ct.style.display='Block'">M</button>
        <p id="tt"></p>
        <div id="ct">
            <button id="capturea">Capture</button>
            <input type=file name=filename id=file oninput="test()" o</input>
            <button type=button onclick='test()'>Display</button>

            <select class="csels" id="stextures" onchange="selT(this.value)">
                <option>Choose Texture</option>
            </select>
            <button id="bw" onclick="setWorld(stextures.value)">Open Editor</button>
            <select id="meshes" class="csels" onchange="chooseMesh(this.value)">
                <option>Create Object</option>
                <option>Box</option>
                <option>Sphere</option>
                <option>Line</option>
                <option>Cylinder</option>
                <option>Label</option>
                <option>Torus</option>

            </select>
            <select class="csels" id="smeshes" onchange="selMesh(this.value)">
                <option>Choose Object</option>
            </select>
            <button onclick="editMesh()">Editor</button>
            <button onclick="if(blight)blight=false;else blight=true">Light</button>
            <button onclick="SetVr();">VR</button>
            <div id="dparam">
                <button onclick="applay(params.value)">Apply</button>
                <button onclick="dparam.style.display='none'">close</button>
                <textarea id="params"></textarea>
            </div>

        </div>
    </div>
</div>

    <script src="js/ImageData-polyfill.js"></script>
    <script src="js/canvas.toBlob-polyfill.js"></script>
    <script src="js/three.min.js"></script>


    <script src="js/OrbitControls.js"></script>
    <script src="TrackballControls.js"></script>
    <script src="js/CubemapToEquirectangular.js"></script>
    <script src="DeviceOrientationControls.js"></script>

    <script src="textures.js"></script>

    <script>
    </script>

    <script>
        var pr1, pr2, pr3, blight = false,
            vrmode = false,
            gap = 1
        var equi;
        var ObSelected = null;

        var container, stats;
        var camera, scene, renderer;
        var controls;

        var radius = 100,
            INTERSECTED,
            theta = 0;

        window.addEventListener('load', function() {
            init();
            animate();
        });
        var eyes = new THREE.Group();
        controlsr = new THREE.DeviceOrientationControls(eyes);
        const raycaster = new THREE.Raycaster();
        const pointer = new THREE.Vector2();

        function fraycast(event) {
            pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
            pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }
        var cubeCamera;
        var textureLoader = new THREE.TextureLoader();
        var light = new THREE.DirectionalLight(0xaaaaaa, .71);
        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
      
      
         camera.position.set(0, 0, 1);
       // 
        cameral = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
        camerar = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
 
        cameral.position.x = -gap;
        camerar.position.x = gap;
        eyes.add(cameral);
        eyes.add(camerar);
        eyes.add(new THREE.Vector3( 0, 0, 0 ))
        eyes.position.x=0;eyes.position.y=30;eyes.position.z=10;
      

        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 1);

            scene = new THREE.Scene();
            //////////////////////////////////
            s = new THREE.Mesh(
                new THREE.SphereGeometry(1, 16, 16),
                new THREE.MeshPhongMaterial({
                    //	map:         THREE.ImageUtils.loadTexture('https://cdn.britannica.com/52/77152-050-9C010169/Joanne-Woodward-The-Three-Faces-of-Eve.jpg'),
                    color: "#00ff00"
                })
            );
            light4 = new THREE.PointLight(0xffffff, 2, 500);
            light4.add(s);
            //	light4.add( new THREE.Mesh( s, new THREE.MeshBasicMaterial( { color: 0xffaa00 } ) ) );
            scene.add(light4);
            ////////////////////////
        
            scene.add(eyes);
            light.position.set(1, 1, 1); //.normalize();
            scene.add(light);

            alight = new THREE.AmbientLight(0x888888);
            scene.add(alight)

            textureLoader.load(art[0].pic, function(texture) {

                texture.mapping = THREE.UVMapping;

                matworld1 = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide,
                    map: texture,
                    transparent: true,
                    opacity: 1 //.450
                });
                world1 = new THREE.Mesh(new THREE.SphereBufferGeometry(900, 312, 116), matworld1);
                world1.scale.x = -1;
                world1.name = "world";
                world1.name = {
                    name: "World",
                    r: 900,
                    sx: 312,
                    sy: 116,
                    x: 0,
                    y: 0,
                    z: 0,
                    rx: 0,
                    ry: 0,
                    rz: 0,
                    rpx: 1,
                    rpy: 1,
                    ofx: 0,
                    ofy: 0,
                    rot: 0,
                    piv: "",
                    pic: "".pic
                }
                scene.add(world1);
            })


            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);
            renderer.setScissorTest(false);
            equi = new CubemapToEquirectangular(renderer, true);
            setUpSels();
            //     controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls = new THREE.TrackballControls(camera, renderer.domElement);
            //  setTimeout(function(){  controls = new THREE.TrackballControls( camera, renderer.domElement );},5000);

            controls.rotateSpeed = 1.0;
            controls.zoomSpeed = 1.2;
            controls.panSpeed = 0.8;

            controls.keys = ['KeyA', 'KeyS', 'KeyD'];
            window.addEventListener('resize', onWindowResize, false);
            onWindowResize();

            document.getElementById('capturea').addEventListener('click', function(e) {

                equi.update(camera, scene);

            });

            renderer.domElement.addEventListener('click', fraycast); // document.addEventListener("click", onPointerMove );//, false

            //controls2 = new DeviceOrientationControls(camera);

        }

        function selT(v) {

            for (var i = 0; i < art.length; i++) {
                if (art[i].name === v) {
                    ObSelected.material.map = THREE.ImageUtils.loadTexture(art[i].pic);
                    i = art.length;
                }

            }

        }

        function setUpSels() {
            var s = stextures.innerHTML + "<option>";

            for (var i = 0; i < art.length; i++) {
                s += "<option>" + art[i].name + "</option>";

            }

            stextures.innerHTML = s;
            setupMeshs();
        }

        function setupMeshs() {
            var ms = scene.children;
            var s = smeshes.innerHTML;
            for (var i = 0; i < ms.length; i++) {
                if (ms[i].name != undefined) {
                    s += "<option>" + ms[i].name + "</option>";
                }
                smeshes.innerHTML = s;
            }
        }

        function chooseMesh(m) {
            var n = prompt("Name");
            var op = document.createElement("option");
            // op.innerHTML=n;    
            if (m === "Box") {

                var m = Box(n, 10, 10, 10);
                scene.add(m);
                ObSelected = m;
                selMesh.value = m.name;

                op.innerHTML = m.name.name;
                smeshes.appendChild(op);

            }
            if (m === "Sphere") {
                var m = Sphere(n, 5, 80, 40);
                scene.add(m);
                ObSelected = m;
                selMesh.value = m.name;
                op.innerHTML = m.name.name;
                smeshes.appendChild(op);

            }

            if (m === "Cylinder") {
                var m = Cylinder(name, 5, 5, 20, 64, false);
                scene.add(m);
                ObSelected = m;
                selMesh.value = m.name;
                op.innerHTML = m.name.name;
                smeshes.appendChild(op);

            }
            if (m === "Torus") {
                var m = Torus(n, 10, 3, 16, 100);
                op.innerHTML = m.name.name;
                smeshes.appendChild(op);
                scene.add(m);
                ObSelected = m;
                selMesh.value = m.name;

            }

        }

        function crOb(texture, geom, pos) {

            return new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
                map: texture,
                transparent: true //,
            }));


        }

        function crObject(callback) {
            if (callback != undefined) {
                var c = new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
                    map: texture //,
                    //  color: Math.random() * 0xffffff
                }));

                callback(c)

            }
        }

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            camerar.aspect = window.innerWidth / window.innerHeight;
            camerar.updateProjectionMatrix();
          cameral.aspect = window.innerWidth / window.innerHeight;
            cameral.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }
        function WindowResize(x, y, cam, rend) {
                windowHalfX = window.innerWidth / 2;
                windowHalfY = window.innerHeight / 2;
                cam.aspect = x / y;
                cam.updateProjectionMatrix();
                rend.setSize(x, y);

            }

        function animate() {

            requestAnimationFrame(animate);
            if (vrmode) controlsr.update();
            else controls.update();
           
            render();

        }

        function render() {
            //   light.position.set(canera.position.x,camera.position.y,camera.position.z)
            if (blight) {
                const time = Date.now() * 0.0005;
                light.position.y += 0.005;
                light.position.z += 0.0080105;
                light4.position.x = Math.sin(time * .9101013) * 100.00;
                light4.position.y = Math.cos(time * .061017) * 100.2;
                light4.position.z = -Math.sin(time * .052015) * 100.1;
               // light4.rotation.y += 0.014;
                eyes.position.x=light4.position.x
        eyes.position.y=light4.position.y
        eyes.position.z=light4.position.z
     //   tt.innerHTML=eyes.position.x+"<br>"+eyes.position.y+"<br>"+eyes.position.z;



            }

            if (!vrmode) {


            if (ct.style.display != 'none') { //  controls2.update();
                raycaster.setFromCamera(pointer, camera);

                const intersects = raycaster.intersectObjects(scene.children, false);

                if (intersects.length > 0) {

                    if (INTERSECTED != intersects[0].object) {


                        //	if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

                        INTERSECTED = intersects[0].object;
                        ObSelected = INTERSECTED;
                        params.value = JSON.stringify(INTERSECTED.name).replace(/{/g, "{\n").replace(/}/g, "\n}").replace(/,/g, "\n");

                        if (INTERSECTED.name.name != "World") {
                            dparam.style.display = 'block';


                        } else {

                            dparam.style.display = "none";

                        }

                    }

                } else {

                    INTERSECTED = null;

                }
            }
          
              //  eyes.position=camera.position;
              //  eyes.rotation=camera.rotation;
                
                renderer.render(scene, camera);
            } else {
             //   camera2.position=camera.position;
              //  camera2.rotation=camera.rotation;     
                renderer.setViewport(0, 0, window.innerWidth / 2, window.innerHeight);
                renderer.setScissor(0, 0, window.innerWidth / 2, window.innerHeight);
                renderer.setScissorTest(true);
                cameral.aspect = (window.innerWidth / 2) / window.innerHeight;
                cameral.updateProjectionMatrix();
                renderer.render(scene, cameral);

                renderer.setViewport(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
                renderer.setScissor(window.innerWidth / 2, 0, window.innerWidth / 2, window.innerHeight);
                renderer.setScissorTest(true);
                camerar.aspect = (window.innerWidth / 2) / window.innerHeight;
                camerar.updateProjectionMatrix();
                renderer.render(scene, camerar);

                // pingpong
                /*      if (count % 2 === 0) {
                mtex.envMap = cubeCamera1.renderTarget //.texture;
                cubeCamera2.update(renderer, scene);
            } else {
                mtex.envMap = cubeCamera2.renderTarget //.texture;
                cubeCamera1.update(renderer, scene);
            }*/
            }
        }

        function test() {
            var file = document.getElementById('file').files[0];
            var reader = new FileReader();
            reader.onload = function(e) {
                var image = document.createElement("img");
                image.src = e.target.result;
                //   document.body.appendChild(image);
                ObSelected.name.pic = image.src;

                if (ObSelected.name.name === "World" && !confirm("Are you sure you want to set this background?")) return;
                else dparam.style.display = "block"




                    params.value = JSON.stringify(ObSelected.name).replace(/{/g, "{\n").replace(/}/g, "\n}").replace(/,/g, "\n");

                applay(params.value)



            }
            reader.readAsDataURL(file);
        }

        function selMesh(v) {
            alert(v)
            //  ObSelected=scene.getObjectByName(v);
            // alert(ObSelected.name.w)
            var ar = scene.children

            for (var i = 0; i < ar.length; i++) {
                if (ar[i].name.name === v) {
                    ObSelected = ar[i];


                    alert(JSON.stringify(ar[i].name));
                    i = ar.length;
                }
            }
            /**/
        }

        function editMesh() {
            if (ObSelected != null) {
                //    alert(ObSelected.parameters)
            }
        }

        function applay(v) {

            v = v.replace(/{\n/g, "{").replace(/\n}/g, "}").replace(/\n/g, ",")
            var o = JSON.parse(v);
            ObSelected.position.set(o.x, o.y, o.z);
            if (o.rx != undefined && o.ry != undefined && o.rz != undefined) {
                ObSelected.rotation.x = o.rx;
                ObSelected.rotation.y = o.ry;
                ObSelected.rotation.z = o.rz;
                ObSelected.name = o;
            }
            //textureLoader.load(o.pic,function(texture){
            //var texture=ObSelected.material.map;

            //alert(o.pic)



            if (o.name.indexOf("Box") > -1) {
                var g = new THREE.BoxBufferGeometry(o.w, o.l, o.h);
                ObSelected.geometry = g;
            }
            if (o.name.indexOf("Sphere") > -1) {
                g = new THREE.SphereGeometry(o.r, o.sx, o.sy);
                ObSelected.geometry = g;
            }
            if (o.name.indexOf("Cylinder") > -1) {
                alert("c")
                //    alert(o.r1+"........."+o.r2)
                var g = new THREE.CylinderGeometry(o.r1, o.r2, o.h, o.s);
                ObSelected.geometry = g;

            }
            if (o.name.indexOf("Torus") > -1) {

                var g = geometry = new THREE.TorusGeometry(o.r, o.tk, o.rs, o.ts)
                ObSelected.geometry = g;

            }
            ObSelected.material.map = THREE.ImageUtils.loadTexture(o.pic);
            //ObSelected.material.map=THREE.ImageUtils.loadTexture(o.pic);
            ObSelected.material.map.wrapS = ObSelected.material.map.wrapT = THREE.RepeatWrapping;

            ObSelected.material.map.repeat.set(o.rpx, o.rpy);
            ObSelected.material.map.offset.x = o.ofx; //,o.ofy)
            ObSelected.material.map.offset.y = o.ofy;
            ObSelected.material.map.rotation = o.rot;
            ObSelected.material.needsUpdate = true;


            params.name = o;

            render();

            //   });

        }

        function setWorld(v) {

            dparam.style.display = "block"

        }
        function SetVr() {
    if (vrmode) {

        renderer.setScissorTest(false);
        vrmode = false;
        onWindowResize();;
       // controls.enabled = false;
        controlsr.connect();

        vrmode = false;
        eyes.position.x=camera.position.x;
        eyes.position.y=camera.position.y;
        eyes.position.z=camera.position.z;
        eyes.rotation.y=Math.PI;
        render()
        closeFullscreen(renderer.domElement)
    } else {
        eyes.position = camera.position;
        vrmode = true;
        controls.enabled = true;
        controlsr.desconnect;
        render();
        openFullscreen(renderer.domElement);
    }
}

function openFullscreen(elem) {
  
  if (elem.requestFullscreen) {
    elem.requestFullscreen();
} else if (elem.webkitRequestFullscreen) { /* Safari */
    elem.webkitRequestFullscreen();
  } else if (elem.msRequestFullscreen) { /* IE11 */
    elem.msRequestFullscreen();
  }
  onWindowResize();
  render();
}
function closeFullscreen(elem) {

  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) { /* Safari */
    document.webkitExitFullscreen();
  } else if (document.msExitFullscreen) { /* IE11 */
    document.msExitFullscreen();
  }
  onWindowResize();render();
}
    </script>

</body>

</html>
