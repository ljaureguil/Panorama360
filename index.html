<!DOCTYPE html>
<html lang="en">

<head>
    <title>CubemapToEquirectangular - Managed</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            color: white;
            margin: 0px;
            overflow: hidden;
        }
        #capture {
            position: absolute;
            left: 20px;
            top: 20px;
            padding: 10px;
            border: 1px solid white;
            z-index: 100;
            cursor: pointer;
            background-color: rgba(0, 0, 0, .4);
        }
        .csels{
            background:rgba(100, 100,1000,.35);
            color:white;
        }
        button{
            margin: 5px;
           background:rgba(100, 100,1000,.35);
            color:white;
            
        }
        select{
            margin: 5px;
        }
    </style>
</head>

<body>
  

    <div id="capture"><button id="capturea">Capture</button>
  <input type=file name=filename id=file oninput="test()">
    <button type=button onclick='test()'>Display</button>
 
    <select class="csels"  id="stextures" onchange="selT(this.value)">
        <option>Choose Texture</option>
    </select>
   <select id="meshes" class="csels" onchange="chooseMesh(this.value)">
        <option>Create Object</option>
        <option>Box</option>
        <option>Sphere</option>
        <option>Line</option>
        <option>Cylinder</option>
        <option>Label</option>     
        <option>Torus</option> 

    </select>
    <select class="csels"  id="smeshes" onchange="selMesh(this.value)">
        <option>Choose Object</option>
    </select>
    <button onclick="editMesh()">Edit Obj</button>
    </div> 
  
    <script src="js/ImageData-polyfill.js"></script>
    <script src="js/canvas.toBlob-polyfill.js"></script>
    <script src="js/three.min.js"></script> 
  

    <script src="js/OrbitControls.js"></script> 
      <script src="TrackballControls.js"></script>
    <script src="js/CubemapToEquirectangular.js"></script>
   
    <script src="textures.js"></script>

    <script>
 
    </script>
    
    <script>

var pr1, pr2, pr3
        var equi;
        var ObSelected=null;

        var container, stats;
        var camera, scene, renderer;
        var controls;

        var radius = 100,
            theta = 0;

        window.addEventListener('load', function() {
            init();
            animate();
        });


        const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function onPointerMove( event ) {

	// calculate pointer position in normalized device coordinates
	// (-1 to +1) for both components

	pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
   // alert(pointer.y)

}



        var cubeCamera;
       
        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(1, 1, 1);

            scene = new THREE.Scene();

            var light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);

			alight = new THREE.AmbientLight( 0xaaaaaa );
			scene.add(alight)
            var textureLoader = new THREE.TextureLoader();
             textureLoader.load(art[0].pic, function(texture) {

                texture.mapping = THREE.UVMapping;

                matworld1 = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide,
                    map: texture,
                    transparent: true,
                    opacity: 1 //.450
                });
                world1 = new THREE.Mesh(new THREE.SphereBufferGeometry(900, 312, 116), matworld1);
                world1.scale.x = -1;
                scene.add(world1);
            })
     
          
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);

            equi = new CubemapToEquirectangular(renderer, true);
   setUpSels();
       //     controls = new THREE.OrbitControls(camera, renderer.domElement);
controls = new THREE.TrackballControls( camera, renderer.domElement );
    //  setTimeout(function(){  controls = new THREE.TrackballControls( camera, renderer.domElement );},5000);

controls.rotateSpeed = 1.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;

controls.keys = [ 'KeyA', 'KeyS', 'KeyD' ];
          window.addEventListener('resize', onWindowResize, false);
            onWindowResize();

            document.getElementById('capturea').addEventListener('click', function(e) {

                equi.update(camera, scene);
         
            });
  
        document.addEventListener("click", onPointerMove );
        
        }
        function selT(v){
     
            for( var i=0;i<art.length;i++){
                if(art[i].name===v){
                      ObSelected.material.map=THREE.ImageUtils.loadTexture(art[i].pic);
                    i=art.length;
                }
        
            }   
          
        }
        function setUpSels(){
             var s=stextures.innerHTML+"<option>";
             
            for( var i=0;i<art.length;i++){
                s+="<option>"+art[i].name+"</option>";
        
            } 
   
            stextures.innerHTML=s;
          setupMeshs();
        }

 function setupMeshs(){
    var ms=scene.children;
    var s=smeshes.innerHTML;
    for(var i=0;i<ms.length;i++){
        if(ms[i].name!=undefined){
        s+="<option>"+ms[i].name+"</option>";
}
smeshes.innerHTML=s;
    }
}
function chooseMesh(m){
        var n=prompt("Name");
        var op=document.createElement("option");
  // op.innerHTML=n;    
  if(m==="Box"){
  
      var w=prompt("Width")*1;
      var d=prompt("Depth")*1;
      var h=prompt("Heigth")*1;
      var m=Box(n,w,d,h)
      m.position.x=prompt("Position X")*1;
   m.position.y=prompt("Position Y")*1;
   m.position.z=prompt("Position Z")*1
   scene.add(m);
   op.innerHTML=m.name;    
   smeshes.appendChild(op);

  }
  if(m==="Sphere"){
   var r=prompt("Radius?")*1;
  var m=Sphere(r,80,40);
   m.position.x=prompt("Position X")*1;
   m.position.y=prompt("Position Y")*1;
   m.position.z=prompt("Position Z")*1
   scene.add(m);
   op.innerHTML=m.name;   
   smeshes.appendChild(op);

}

if(m==="Cylinder"){
    var r1=prompt("Radius1")*1;
      var r2=prompt("Radius2")*1;
      var h=prompt("Heigth")*1;
      var s=prompt("Segments")*1;
      var cap=prompt("Cap true or false",false);
      alert("r1,r2,h,s,cap\n\n"+r1+"\n"+r2+"\n"+h+"\n"+s+"\n"+cap+"\n") 
    var m=Cylinder(name,r1,r2,h,s,cap);
 
  
   scene.add(m);
   op.innerHTML=m.name;   
   smeshes.appendChild(op);

}
if(m==="Torus"){
   
    var r=prompt("Radius")*1;
    var rs=prompt("segments")*1;
    var tk=prompt("Thicknes")*1;
    var ts=prompt("Transversal Segments")*1;
    var m=Torus(n,r,rs,tk,ts);
    m.position.x=prompt("Position X")*1;
   m.position.y=prompt("Position Y")*1;
   m.position.z=prompt("Position Z")*1
   op.innerHTML=m.name;   
    smeshes.appendChild(op);
    scene.add(m)

}

}

function crOb(texture,geom,pos){

    return  new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
					map:texture,
                    transparent:true    //,
                      }));


}
function crObject(callback){
    if(callback!=undefined){
        var c=new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
					map:texture    //,
                  //  color: Math.random() * 0xffffff
                }));

    callback(c)

    }
}

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


        function animate() {

            requestAnimationFrame(animate);

            controls.update();
            render();

        }

        function render() {

// update the picking ray with the camera and pointer position
raycaster.setFromCamera( pointer, camera );

// calculate objects intersecting the picking ray
const intersects = raycaster.intersectObjects( scene.children );

for ( let i = 2; i < intersects.length; i ++ ) {

    intersects[ i ].object.material.color.set( 0xff0000 );

}
/*
else{
    intersects[ i ].object.material.color.set( 0xffffff );
}
*/





            renderer.render(scene, camera);

        }

        function test() {
            var file = document.getElementById('file').files[0];
           var reader  = new FileReader();
            reader.onload = function(e)  {
                var image = document.createElement("img");
                image.src = e.target.result;
             //   document.body.appendChild(image);
            
             ObSelected.material.map=THREE.ImageUtils.loadTexture(image.src);
        //     pr2.material.needsUpdate=true;
        //      render()
              
         
            }
             reader.readAsDataURL(file);
         }
function selMesh(v){
  //  alert(v)
  ObSelected=scene.getObjectByName(v);
 
 /*
    for( var i=0;i<scene.children.length;i++){
        if(scene.children[i].name===v){
            ObSelected=scene.children[i];
            i=scene.children.length;
 //  alert(JSON.stringify(ObSelected.geometry.attributes ))
        }
    }
 */
}
function editMesh(){
    if(ObSelected!=null){
    //    alert(ObSelected.parameters)
    }
}

    </script>

</body>

</html>
