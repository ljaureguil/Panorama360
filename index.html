<!DOCTYPE html>
<html lang="en">

<head>
    <title>CubemapToEquirectangular - Managed</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: Monospace;
            background-color: #f0f0f0;
            color: white;
            margin: 0px;
            overflow: hidden;
        }
        #capture {
            position: absolute;
            left: 20px;
            top: 20px;
            padding: 10px;
            border: 1px solid white;
            z-index: 100;
            cursor: pointer;
            background-color: rgba(0, 0, 0, .4);
        }
        .csels{
            background:rgba(100, 100,1000,.35);
            color:white;
        }
        button{
            margin: 5px;
           background:rgba(100, 100,1000,.35);
            color:white;
            
        }
        select{
            margin: 5px;
        }
        #dparam{
            width: 100%;
            height: 100%;
            border-style: solid;
               display:none;
       
        }
        #params{
         
            width: 50%;
            height: 200px;
            background: rgba(255,255,255,.75);

        }
        #file{
            background: url(https://icons-for-free.com/iconfiles/png/512/folder+open+icon-1320161390409087972.png);
            background-size: 100% 100%;;
        }
        #ct{
            display: none;
        }
    </style>
</head>

<body>
  




    <div id="capture">
        <button id="bm" onclick="if(ct.style.display!='none')ct.style.display='none';else ct.style.display='Block'">M</button>
        <div id="ct">
        <button id="capturea">Capture</button>
  <input type=file name=filename id=file oninput="test()" o</input>
    <button type=button onclick='test()'>Display</button>
 
    <select class="csels"  id="stextures" onchange="selT(this.value)">
        <option>Choose Texture</option>
    </select>
   <select id="meshes" class="csels" onchange="chooseMesh(this.value)">
        <option>Create Object</option>
        <option>Box</option>
        <option>Sphere</option>
        <option>Line</option>
        <option>Cylinder</option>
        <option>Label</option>     
        <option>Torus</option> 

    </select>
    <select class="csels"  id="smeshes" onchange="selMesh(this.value)">
        <option>Choose Object</option>
    </select>
    <button onclick="editMesh()">Edit Obj</button>
  <div id="dparam">
    <button onclick="applay(params.value)">Apply</button>
    <button onclick="dparam.style.display='none'">close</button>
  <textarea id="params"></textarea>
  </div>
</div>
</div>
    <script src="js/ImageData-polyfill.js"></script>
    <script src="js/canvas.toBlob-polyfill.js"></script>
    <script src="js/three.min.js"></script> 
  

    <script src="js/OrbitControls.js"></script> 
      <script src="TrackballControls.js"></script>
    <script src="js/CubemapToEquirectangular.js"></script>
   
    <script src="textures.js"></script>

    <script>
 
    </script>
    
    <script>

var pr1, pr2, pr3
        var equi;
        var ObSelected=null;

        var container, stats;
        var camera, scene, renderer;
        var controls;

        var radius = 100,INTERSECTED,
            theta = 0;

        window.addEventListener('load', function() {
            init();
            animate();
        });


        const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function fraycast( event ) {

	// calculate pointer position in normalized device coordinates
	// (-1 to +1) for both components

	pointer.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	pointer.y = - ( event.clientY / window.innerHeight ) * 2 + 1;
  //  params.value=JSON.stringify(pointer)
   // alert(pointer.y)

}



        var cubeCamera;
       
        function init() {

            container = document.createElement('div');
            document.body.appendChild(container);

            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(0, 0, 1);

            scene = new THREE.Scene();

            var light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);

			alight = new THREE.AmbientLight( 0xaaaaaa );
			scene.add(alight)
            var textureLoader = new THREE.TextureLoader();
             textureLoader.load(art[0].pic, function(texture) {

                texture.mapping = THREE.UVMapping;

                matworld1 = new THREE.MeshBasicMaterial({
                    side: THREE.DoubleSide,
                    map: texture,
                    transparent: true,
                    opacity: 1 //.450
                });
                world1 = new THREE.Mesh(new THREE.SphereBufferGeometry(900, 312, 116), matworld1);
                world1.scale.x = -1;
                world1.name="world"
                scene.add(world1);
            })
     
          
            renderer = new THREE.WebGLRenderer({
                antialias: true
            });
            renderer.setClearColor(0xf0f0f0);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.sortObjects = false;
            container.appendChild(renderer.domElement);

            equi = new CubemapToEquirectangular(renderer, true);
   setUpSels();
       //     controls = new THREE.OrbitControls(camera, renderer.domElement);
controls = new THREE.TrackballControls( camera, renderer.domElement );
    //  setTimeout(function(){  controls = new THREE.TrackballControls( camera, renderer.domElement );},5000);

controls.rotateSpeed = 1.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;

controls.keys = [ 'KeyA', 'KeyS', 'KeyD' ];
          window.addEventListener('resize', onWindowResize, false);
            onWindowResize();

            document.getElementById('capturea').addEventListener('click', function(e) {

                equi.update(camera, scene);
         
            });
  
      renderer.domElement.addEventListener( 'click', fraycast ); // document.addEventListener("click", onPointerMove );//, false
    //  const axesHelper = AxesHelper( 5 );
//scene.add( axesHelper );
//controls2 = new DeviceOrientationControls(camera);

        }
        function selT(v){
     
            for( var i=0;i<art.length;i++){
                if(art[i].name===v){
                      ObSelected.material.map=THREE.ImageUtils.loadTexture(art[i].pic);
                    i=art.length;
                }
        
            }   
          
        }
        function setUpSels(){
             var s=stextures.innerHTML+"<option>";
             
            for( var i=0;i<art.length;i++){
                s+="<option>"+art[i].name+"</option>";
        
            } 
   
            stextures.innerHTML=s;
          setupMeshs();
        }

 function setupMeshs(){
    var ms=scene.children;
    var s=smeshes.innerHTML;
    for(var i=0;i<ms.length;i++){
        if(ms[i].name!=undefined){
        s+="<option>"+ms[i].name+"</option>";
}
smeshes.innerHTML=s;
    }
}
function chooseMesh(m){
        var n=prompt("Name");
        var op=document.createElement("option");
  // op.innerHTML=n;    
  if(m==="Box"){
  
      var m=Box(n,10,10,10);
    scene.add(m);
    ObSelected=m; selMesh.value=m.name;
   
   op.innerHTML=m.name.name;    
   smeshes.appendChild(op);

  }
  if(m==="Sphere"){
   var m=Sphere(n,5,80,40);
   scene.add(m); ObSelected=m; selMesh.value=m.name;
   op.innerHTML=m.name.name ;   
   smeshes.appendChild(op);

}

if(m==="Cylinder"){
     var m=Cylinder(name,5,5,20,64,false);
   scene.add(m); ObSelected=m; selMesh.value=m.name;
   op.innerHTML=m.name.name ;   
   smeshes.appendChild(op);

}
if(m==="Torus"){
     var m=Torus(n,10,3,16,100);
    op.innerHTML=m.name.name ;   
    smeshes.appendChild(op);
    scene.add(m); ObSelected=m; selMesh.value=m.name;

}

}

function crOb(texture,geom,pos){

    return  new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
					map:texture,
                    transparent:true    //,
                      }));


}
function crObject(callback){
    if(callback!=undefined){
        var c=new THREE.Mesh(geom, new THREE.MeshPhongMaterial({
					map:texture    //,
                  //  color: Math.random() * 0xffffff
                }));

    callback(c)

    }
}

        function onWindowResize() {

            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();

            renderer.setSize(window.innerWidth, window.innerHeight);

        }


        function animate() {

            requestAnimationFrame(animate);

            controls.update();
            render();

        }

        function render() {
          
            if(ct.style.display!='none'){ //  controls2.update();
			raycaster.setFromCamera( pointer, camera );

				const intersects = raycaster.intersectObjects( scene.children, false );

				if ( intersects.length > 0 ) {
                
					if ( INTERSECTED != intersects[ 0 ].object  ) {


					//	if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );

						INTERSECTED = intersects[ 0 ].object;
     
						if(INTERSECTED.name!="world"){
                            dparam.style.display='block'
                            params.value=JSON.stringify(INTERSECTED.name).replace(/{/g,"{\n").replace(/}/g,"\n}").replace(/,/g,"\n");

                            ObSelected=INTERSECTED;
                        
                        }
                        else{
    
                        }

					}

				} else {
                  //  if(INTERSECTED.name!="world"){
				//	if ( INTERSECTED ) INTERSECTED.material.color.setHex( INTERSECTED.currentHex );
//}
					INTERSECTED = null;

				}
}


            renderer.render(scene, camera);

        }

        function test() {
            var file = document.getElementById('file').files[0];
           var reader  = new FileReader();
            reader.onload = function(e)  {
                var image = document.createElement("img");
                image.src = e.target.result;
             //   document.body.appendChild(image);
            
             ObSelected.material.map=THREE.ImageUtils.loadTexture(image.src);
             
 
        //     pr2.material.needsUpdate=true;
        //      render()

    /*    setTimeout(function(){ ObSelected.material.map.wrapS =  ObSelected.material.map.wrapT = THREE.RepeatWrapping;
ObSelected.material.map.repeat.set(2,2);},20000)*/
              
         
            }
             reader.readAsDataURL(file);
         }
function selMesh(v){
    alert(v)
//  ObSelected=scene.getObjectByName(v);
 // alert(ObSelected.name.w)
    var ar=scene.children
 
    for( var i=0;i<ar.length;i++){
        if(ar[i].name.name===v){
            ObSelected=ar[i];
       
            
   alert(JSON.stringify(ar[i].name));
        i=ar.length;
        }
    }
 /**/
}
function editMesh(){
    if(ObSelected!=null){
    //    alert(ObSelected.parameters)
    }
}
function applay(v){

      v=v.replace(/{\n/g,"{").replace(/\n}/g,"}").replace(/\n/g,",")
     var o= JSON.parse(v);
     ObSelected.position.set(  o.x,o.y, o.z );
    if(o.rx!=undefined && o.ry!=undefined && o.rz!=undefined){ 
         ObSelected.rotation.x=o.rx;
        ObSelected.rotation.y=o.ry;
        ObSelected.rotation.z=o.rz;
             ObSelected.name=o;
}
var texture=ObSelected.material.map;
//ObSelected.material.map.wrapS =  ObSelected.material.map.wrapT = THREE.RepeatWrapping;

texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.x = 200;
            texture.repeat.y = 200;
            texture.offset.set( 0, 0 );




//ObSelected.material.map.repeat.set(o.rpx, o.rpy);
//ObSelected.material.needsUpdate=true;

//Checar esto de la textura

      if(o.name.indexOf("Box")>-1){
       var g=new THREE.BoxBufferGeometry( o.w,o.l,o.h);
      ObSelected.geometry=g;
 //     ObSelected.material.map.wrapS =  ObSelected.material.map.wrapT = THREE.RepeatWrapping;
//ObSelected.material.map.repeat.set(o.rpx, o.rpy);
O//bSelected.material.needsUpdate=true;
       }
     if(o.name.indexOf("Sphere")>-1){
       g = new THREE.SphereGeometry( o.r, o.sx, o.sy );
        ObSelected.geometry=g;
      }
     if(o.name.indexOf("Cylinder")>-1){alert("c")
     //    alert(o.r1+"........."+o.r2)
        var g=new THREE.CylinderGeometry( o.r1, o.r2, o.h, o.s);
        ObSelected.geometry=g;

     }
     if(o.name.indexOf("Torus")>-1){
     
        var g=geometry = new THREE.TorusGeometry( o.r, o.tk, o.rs, o.ts )
        ObSelected.geometry=g;

     }
 
  

}

    </script>

</body>

</html>
